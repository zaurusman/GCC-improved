%{
	#include <iostream>
	#include <stdlib.h>
	#include "hw3_output.hpp"
	#include "attributes.hpp"
	#include "utils.hpp"
	#include "symbols.hpp"

	using namespace std;
	using namespace output;
	extern int yylex();
	extern int yylineno;
	int yyerror(const char * message);
	symbols::SymbolTable symtab;

%}


%token <type> INT
%token <type> BYTE
%token B
%token <type> BOOL
%token TRUE
%token FALSE
%token RETURN
%token BREAK
%token CONTINUE
%token SC
%token <name> ID
%token <val> NUM
%token <name> STRING

%right ASSIGN

%left OR
%left AND

%left EQ_NEQ
%left RELOP

%left PLUS_MINUS
%left MUL_DIV

%right NOT

%left RPAREN LPAREN 
%left RBRACE LBRACE	

%nonassoc ELSE
%nonassoc IF
%nonassoc WHILE

%type <exp> Exp
%type <type> Type
%type <exp> Call

%%

Program       :  M1 Statements                                  {symtab.myEndScope();}
;
M1            :                                                 {symtab.init();}
;
Statements    :  Statement                                      {}
              |  Statements Statement                           {}
;

Statement     :  LBRACE M2 Statements RBRACE                    {symtab.myEndScope();}
              |  Type ID SC                                     {declaration($1,$2);}
              |  Type ID ASSIGN Exp SC                          {declaration($1,$2); assign($2,$4);}
              |  ID ASSIGN Exp SC                               {assign($1,$3);}
              |  Call SC                                        {}
              |  RETURN SC                                      {/*myReturn();*/}
              |  IF LPAREN Exp RPAREN M3 Statement              {symtab.myEndScope();}
              |  IF LPAREN Exp RPAREN M3 Statement {symtab.myEndScope();} ELSE M2 Statement {symtab.myEndScope();}
              |  WHILE LPAREN Exp RPAREN M3 Statement           {symtab.myEndScope();}
              |  BREAK SC                                       {myBreak();}
              |  CONTINUE SC                                    {myCont();}
;

M2            :                                                 {symtab.makeTable();}
;
M3            :                                                 {ifbool(stack.peek(1));}
;

Call          :  ID LPAREN Exp RPAREN                           {call($$,$1,$3);}
;

Type          :  INT                                            {$$ = $1;}
              |  BYTE                                           {$$ = $1;}
              |  BOOL                                           {$$ = $1;}
;

Exp           :  LPAREN Exp RPAREN                              {$$ = $2;}
              |  Exp MUL_DIV Exp                                {binop($$, $1, $3);}
              |  Exp PLUS_MINUS Exp                             {binop($$, $1, $3);}
              |  ID                                             {expId($$,$1);}
              |  Call                                           {$$ = $1;}
              |  NUM                                            {$$.type = INT_T;}
              |  NUM B                                          {numB($$, $1);}
              |  STRING                                         {$$.type = STRING_T;}
              |  TRUE                                           {$$.type = BOOL_T;}
              |  FALSE                                          {$$.type = BOOL_T;}
              |  NOT Exp                                        {logic_not($$, $2);}
              |  Exp AND Exp                                    {logic($$, $1, $3);}
              |  Exp OR Exp                                     {logic($$, $1, $3);}
              |  Exp RELOP Exp                                  {relop($$,$1,$3);}
              |  Exp EQ_NEQ Exp                                 {relop($$,$1,$3);}
              |  LPAREN Type RPAREN Exp                         {cast($$,$2,$4);}
;

%%

int main()
{
	yyparse();
}

int yyerror(const char * message)
{
	output::errorSyn(yylineno);
	exit(0);
}

