%{
	#include <iostream>
	#include <stdlib.h>
	#include "hw3_output.hpp"
	#include "attributes.hpp"
	#include "utils.hpp"

	using namespace std;
	using namespace hw3_output
	using namespace utils
	extern int yylex();
	extern int yylineno;
	int yyerror(const char * message);

%}


%token <type> INT
%token <type> BYTE
%token B
%token <type> BOOL
%token TRUE
%token FALSE
%token RETURN
%token BREAK
%token CONTINUE
%token SC
%token <name> ID
%token <val> NUM
%token <name> STRING

%right ASSIGN

%left OR
%left AND

%left <op> EQ_NEQ
%left <op> RELOP

%left <op> PLUS_MINUS
%left <op> MUL_DIV

%right NOT

%left RPAREN LPAREN 
%left RBRACE LBRACE	

%nonassoc ELSE
%nonassoc IF
%nonassoc WHILE

%type <exp> Exp
%type <type> Type
%type <exp> call

%%

Program       :  Statements                                     {output::printProductionRule(1);} 
;

Statements    :  Statement                                      {output::printProductionRule(2);} 
              |  Statements Statement                           {output::printProductionRule(3);} 
;

Statement     :  LBRACE Statements RBRACE                       {output::printProductionRule(4);} 
              |  Type ID SC                                     {output::printProductionRule(5);} 
              |  Type ID ASSIGN Exp SC                          {output::printProductionRule(6);} 
              |  ID ASSIGN Exp SC                               {output::printProductionRule(7);} 
              |  Call SC                                        {output::printProductionRule(8);} 
              |  RETURN SC                                      {output::printProductionRule(9);} 
              |  IF LPAREN Exp RPAREN Statement                 {output::printProductionRule(10);} 
              |  IF LPAREN Exp RPAREN Statement ELSE Statement  {output::printProductionRule(11);} 
              |  WHILE LPAREN Exp RPAREN Statement              {output::printProductionRule(12);} 
              |  BREAK SC                                       {output::printProductionRule(13);} 
              |  CONTINUE SC                                    {output::printProductionRule(14);} 
;

Call          :  ID LPAREN Exp RPAREN                           {}
;

Type          :  INT                                            {output::printProductionRule(16);} 
              |  BYTE                                           {output::printProductionRule(17);} 
              |  BOOL                                           {output::printProductionRule(18);} 
;

Exp           :  LPAREN Exp RPAREN                              {$$ = $2}
              |  Exp MUL_DIV Exp                                {binop($$,$1,$3);}
              |  Exp PLUS_MINUS Exp                             {binop($$,$1,$3);}
              |  ID                                             {}
              |  Call                                           {$$ = $1}
              |  NUM                                            {$$.type = "int";}
              |  NUM B                                          {$$.type = "byte";}
              |  STRING                                         {$$.type = "string";}
              |  TRUE                                           {$$.type = "bool";}
              |  FALSE                                          {$$.type = "bool";}
              |  NOT Exp                                        {logic_not($$,$1);}
              |  Exp AND Exp                                    {}
              |  Exp OR Exp                                     {}
              |  Exp RELOP Exp                                  {}
              |  Exp EQ_NEQ Exp                                 {}
              |  LPAREN Type RPAREN Exp                         {}
;

%%

int main()
{
	yyparse();
}

int yyerror(const char * message)
{
	output::errorSyn(yylineno);
	exit(0);
}

